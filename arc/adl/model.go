package adl

import (
	"github.com/golangee/architecture/arc/token"
	"runtime"
	"strings"
)

// A Project has multiple modules, like libraries, servers or clients, frontends or backends.
type Project struct {
	Name     token.String
	Comment  token.String
	Modules  []*Module
	Glossary *Glossary
}

func NewProject(name, comment string) *Project {
	return &Project{
		Name:    traceStr(name),
		Comment: traceStr(comment),
	}
}

func (w *Project) PutGlossary(key, val string) *Project {
	if w.Glossary == nil {
		w.Glossary = NewGlossary()
	}

	w.Glossary.Terms[key] = Term{
		Ident:       traceStr(key),
		Description: traceStr(val),
	}

	return w
}

func (w *Project) AddModules(p ...*Module) *Project {
	w.Modules = append(w.Modules, p...)
	return w
}

// An Executable defines an entry point into the application. At least Java and Go support an arbitrary set of
// main entry points.
type Executable struct {
	Comment             token.String
	Name                token.String
	BoundedContextPaths []token.String
}

func NewExecutable(name, comment string) *Executable {
	return &Executable{
		Name:    traceStr(name),
		Comment: traceStr(comment),
	}
}

func (e *Executable) Normalize(ctx Ctx) {
	for i := range e.BoundedContextPaths {
		ctx.applyToken(&e.BoundedContextPaths[i])
	}
}

func (e *Executable) Application(paths ...string) *Executable {
	for _, path := range paths {
		e.BoundedContextPaths = append(e.BoundedContextPaths, traceStr(path))
	}

	return e
}

// A Module is e.g. a server application, a frontend or a shared library.
type Module struct {
	Preamble        Preamble
	Name            token.String // the name of the project
	Comment         token.String
	Generator       *Generator
	BoundedContexts []*BoundedContext
	Executables     []*Executable
}

func NewModule(name, comment string) *Module {
	return &Module{
		Name:    traceStr(name),
		Comment: traceStr(comment),
		Preamble: Preamble{
			Generator: "Code generated by golangee/eearc; DO NOT EDIT.",
		},
	}
}

func (p *Module) AddExecutables(e ...*Executable) *Module {
	p.Executables = append(p.Executables, e...)
	return p
}

func (p *Module) SetLicense(str string) *Module {
	p.Preamble.License = str
	return p
}

func (p *Module) SetGenerator(g *Generator) *Module {
	p.Generator = g
	return p
}

func (p *Module) AddBoundedContexts(d ...*BoundedContext) *Module {
	p.BoundedContexts = append(p.BoundedContexts, d...)
	return p
}

// A Generator describes how this project should be generated.
type Generator struct {
	Go     *Golang
	OutDir token.String // the target directory to (re) write the module
}

func NewGenerator() *Generator {
	return &Generator{}
}

func (g *Generator) SetGo(d *Golang) *Generator {
	g.Go = d
	return g
}

func (g *Generator) SetOutDir(dir string) *Generator {
	g.OutDir = traceStr(dir)
	return g
}

type GoDist struct {
	Arch token.String
	Os   token.String
}

// Golang describes how a Go project (or module) must be created or updated.
type Golang struct {
	Module   token.String // the name of the go module, e.g. github.com/worldiety/supportiety
	GoDist   []*GoDist
	Requires []token.String // require directives
}

func NewGolang() *Golang {
	return &Golang{}
}

func (g *Golang) AddDist(goos, goarch string) *Golang {
	g.GoDist = append(g.GoDist, &GoDist{
		Arch: traceStr(goarch),
		Os:   traceStr(goos),
	})

	return g
}

func (g *Golang) SetModName(name string) *Golang {
	g.Module = traceStr(name)
	return g
}

func (g *Golang) Require(dep string) *Golang {
	g.Requires = append(g.Requires, traceStr(dep))
	return g
}

// A BoundedContext is a cross-cutting thing, which is referenced from various places and contains its own
// ubiquitous language (== glossary).
type BoundedContext struct {
	Name    token.String
	Path    token.String
	Core    []*Package // multiple core packages are allowed, to allow arbitrary large and complex nested (sub or supporting) domains.
	Usecase []*Package // same for the use cases
}

func NewBoundedContext(name, path string) *BoundedContext {
	return &BoundedContext{
		Name: traceStr(name),
		Path: traceStr(path),
	}
}

const (
	nMOD = "$MOD"
	nBC  = "$BC"
)

type Ctx struct {
	Mod string
	BC  string
}

func (c Ctx) applyToken(t *token.String) {
	t.Val = strings.ReplaceAll(t.Val, nMOD, c.Mod)
	t.Val = strings.ReplaceAll(t.Val, nBC, c.BC)
}

// Normalize rewrites all path like things.
func (d *BoundedContext) Normalize(ctx Ctx) {
	d.Path.Val = strings.ReplaceAll(d.Path.Val, nMOD, ctx.Mod)
	ctx.BC = d.Path.Val

	for _, p := range d.Core {
		p.Normalize(ctx)
	}

	for _, p := range d.Usecase {
		p.Normalize(ctx)
	}
}

func (d *BoundedContext) AddCore(l ...*Package) *BoundedContext {
	d.Core = append(d.Core, l...)
	return d
}

func (d *BoundedContext) AddUsecase(l *Package) *BoundedContext {
	d.Usecase = append(d.Usecase, l)
	return d
}

type Package struct {
	Comment      token.String
	Name         token.String
	Repositories []*Interface
	Services     []*Service
	DTOs         []*Struct
	Errors       []*Error
}

func NewPackage(name, comment string) *Package {
	return &Package{Name: traceStr(name), Comment: traceStr(comment)}
}

func (p *Package) AddRepositories(r ...*Interface) *Package {
	p.Repositories = append(p.Repositories, r...)
	return p
}

func (p *Package) AddStructs(d ...*Struct) *Package {
	p.DTOs = append(p.DTOs, d...)
	return p
}

func (p *Package) AddErrors(d ...*Error) *Package {
	p.Errors = append(p.Errors, d...)
	return p
}

func (p *Package) AddServices(s ...*Service) *Package {
	p.Services = append(p.Services, s...)
	return p
}

func (p *Package) Normalize(ctx Ctx) {
	for _, service := range p.Services {
		service.Normalize(ctx)
	}

	for _, o := range p.DTOs {
		o.Normalize(ctx)
	}

	for _, repository := range p.Repositories {
		repository.Normalize(ctx)
	}

	for _, e := range p.Errors {
		e.Normalize(ctx)
	}
}

type PersistenceType string

const (
	PMemory PersistenceType = "in-memory"
	PFile                   = "file"
	PMySQL                  = "mysql"
)

// CRUD represents an autogenerated piece of code to manage entities.
type CRUD struct {
	EntityType *TypeDecl // the actual data type or io.ReadWriter for a generic stream api
	IDType     *TypeDecl // optional custom id type (empty if ID field in EntityType must be used)

	Persistence                              PersistenceType
	InsertOne, FindOne, UpdateOne, DeleteOne bool
	CountAll, FindAll, IterateAll            bool
}

func NewCRUD(entityType *TypeDecl, IDType *TypeDecl, persistence PersistenceType, createOne bool, findOne bool, updateOne bool, deleteOne bool, countAll bool, findAll bool, iterateAll bool) *CRUD {
	return &CRUD{EntityType: entityType, IDType: IDType, Persistence: persistence, InsertOne: createOne, FindOne: findOne, UpdateOne: updateOne, DeleteOne: deleteOne, CountAll: countAll, FindAll: findAll, IterateAll: iterateAll}
}

func (i *CRUD) Normalize(ctx Ctx) {
	i.EntityType.Normalize(ctx)
	if i.IDType != nil {
		i.IDType.Normalize(ctx)
	}
}

type Interface struct {
	Comment token.String
	Name    token.String
	Methods []*Method
	CRUDs   []*CRUD
}

func NewInterface(name, comment string) *Interface {
	return &Interface{
		Comment: traceStr(comment),
		Name:    traceStr(name),
	}
}

func (i *Interface) AddCRUDImpl(crud ...*CRUD) *Interface {
	i.CRUDs = append(i.CRUDs, crud...)
	return i
}

func (i *Interface) Normalize(ctx Ctx) {
	for _, method := range i.Methods {
		method.Normalize(ctx)
	}

	for _, d := range i.CRUDs {
		d.Normalize(ctx)
	}
}

func (i *Interface) AddMethods(m ...*Method) *Interface {
	i.Methods = append(i.Methods, m...)
	return i
}

type Service struct {
	Component *Struct
}

func NewService(name, comment string) *Service {
	return &Service{
		Component: &Struct{
			Comment:    traceStr(comment),
			Name:       traceStr(name),
			Stereotype: traceStr(ServiceComponent),
		},
	}
}

func (s *Service) Normalize(ctx Ctx) {
	s.Component.Normalize(ctx)
}

func (s *Service) AddFields(f ...*Field) *Service {
	s.Component.Fields = append(s.Component.Fields, f...)

	return s
}

func (s *Service) AddMethods(m ...*Method) *Service {
	s.Component.Methods = append(s.Component.Methods, m...)

	return s
}

func (s *Service) AddInjections(m ...*Injection) *Service {
	s.Component.Inject = append(s.Component.Inject, m...)

	return s
}

const (
	// DTO is a data transfer stereotype.
	DTO = "dto"

	// Cfg is a configuration stereotype.
	Cfg = "cfg"

	// ServiceComponent is a service stereotype.
	ServiceComponent = "service"
)

type Injection struct {
	Comment    token.String // why is this needed?
	Name       token.String // usually the field name, but also as a reference/documentation name
	Stereotype token.String // optional stereotype to indicate the type.
	Type       *TypeDecl
}

func NewInjection(name, comment, stereotype string, typ *TypeDecl) *Injection {
	return &Injection{
		Name:       traceStr(name),
		Comment:    traceStr(comment),
		Stereotype: traceStr(stereotype),
		Type:       typ,
	}
}

func (t *Injection) Normalize(ctx Ctx) {
	t.Type.Normalize(ctx)
}

type Error struct {
	Comment token.String
	Name    token.String
	Fields  []*Field
}

func NewError(name, comment string) *Error {
	return &Error{
		Comment: traceStr(comment),
		Name:    traceStr(name),
		Fields:  nil,
	}
}

func (d *Error) Normalize(ctx Ctx) {
	for _, field := range d.Fields {
		field.Normalize(ctx)
	}

}

func (d *Error) AddFields(f ...*Field) *Error {
	d.Fields = append(d.Fields, f...)

	return d
}

type Struct struct {
	Comment    token.String
	Name       token.String
	Stereotype token.String
	Fields     []*Field
	Methods    []*Method
	Inject     []*Injection // optional and arbitrary types to inject like configuration or other services.
}

func NewStruct(name, comment, stereotype string) *Struct {
	return &Struct{
		Comment:    traceStr(comment),
		Name:       traceStr(name),
		Stereotype: traceStr(stereotype),
	}
}

func NewDTO(name, comment string) *Struct {
	return NewStruct(name, comment, DTO)
}

func NewConfig(name, comment string) *Struct {
	return NewStruct(name, comment, Cfg)
}

func (d *Struct) Normalize(ctx Ctx) {
	for _, field := range d.Fields {
		field.Normalize(ctx)
	}

	for _, method := range d.Methods {
		method.Normalize(ctx)
	}

	for _, injection := range d.Inject {
		injection.Normalize(ctx)
	}
}

func (d *Struct) AddFields(f ...*Field) *Struct {
	d.Fields = append(d.Fields, f...)

	return d
}

type Field struct {
	Comment        token.String
	Name           token.String
	Type           *TypeDecl
	Private        bool
	CfgCmdLineFlag bool
}

func NewPrivateField(name, comment string, decl *TypeDecl) *Field {
	return &Field{
		Comment: traceStr(comment),
		Name:    traceStr(name),
		Type:    decl,
		Private: true,
	}
}

func NewField(name, comment string, decl *TypeDecl) *Field {
	return &Field{
		Comment: traceStr(comment),
		Name:    traceStr(name),
		Type:    decl,
		Private: false,
	}
}

// SetCfgCmdLineFlag is only valid within a struct configuration stereotype.
func (f *Field) SetCfgCmdLineFlag(flag bool) *Field {
	f.CfgCmdLineFlag = flag
	return f
}

func (f *Field) Normalize(ctx Ctx) {
	f.Type.Normalize(ctx)
}

type Method struct {
	Comment     token.String
	Name        token.String
	In          []*Param
	Out         []*Param
	Errors      []*TypeDecl // sum type of error types. Non-qualified names are always resolved to package local declarations or fail.
	StubDefault bool        // StubDefault instructs the generator to emit an abstract or default implementation
}

func NewMethod(name, comment string) *Method {
	return &Method{
		Comment:     traceStr(comment),
		Name:        traceStr(name),
		StubDefault: true,
	}
}

func (m *Method) Normalize(ctx Ctx) {
	for _, param := range m.In {
		param.Normalize(ctx)
	}

	for _, param := range m.Out {
		param.Normalize(ctx)
	}

	for _, decl := range m.Errors {
		decl.Normalize(ctx)
	}
}

func (m *Method) AddIn(name, comment string, decl *TypeDecl) *Method {
	m.In = append(m.In, &Param{
		Name:    traceStr(name),
		Comment: traceStr(comment),
		Type:    decl,
	})

	return m
}

func (m *Method) AddOut(name, comment string, decl *TypeDecl) *Method {
	m.Out = append(m.Out, &Param{
		Name:    traceStr(name),
		Comment: traceStr(comment),
		Type:    decl,
	})

	return m
}

func (m *Method) AddErrors(names ...*TypeDecl) *Method {
	m.Errors = append(m.Errors, names...)
	return m
}

func (m *Method) OutParams(p ...*Param) *Method {
	m.In = p
	return m
}

type Param struct {
	Comment token.String
	Name    token.String
	Type    *TypeDecl
}

func (p *Param) Normalize(ctx Ctx) {
	p.Type.Normalize(ctx)
}

func traceStr(v string) token.String {
	_, file, line, _ := runtime.Caller(2)
	str := token.NewString(v)
	str.BeginPos.File = file
	str.BeginPos.Line = line
	str.BeginPos.Col = 1
	str.BeginPos.Offset = -1

	str.EndPos = str.BeginPos
	str.EndPos.Col += len(v)

	return str
}

type Term struct {
	Ident       token.String
	Description token.String
}

type Glossary struct {
	Terms map[string]Term
}

func NewGlossary() *Glossary {
	return &Glossary{
		Terms: map[string]Term{},
	}
}

func (g *Glossary) Put(key, val string) *Glossary {
	if g.Terms == nil {
		g.Terms = map[string]Term{}
	}

	g.Terms[key] = Term{
		Ident:       traceStr(key),
		Description: traceStr(val),
	}

	return g
}

type Preamble struct {
	Generator string
	License   string
}

// A TypeDecl is the generified declaration of named types, consisting of full qualified name, a pointer flag
// and optionally nested other type parameters.
type TypeDecl struct {
	Name       token.String
	TypeParams []*TypeDecl
}

func NewTypeDecl(name string, typeDecl ...*TypeDecl) *TypeDecl {
	return &TypeDecl{
		Name:       traceStr(name),
		TypeParams: typeDecl,
	}
}

func (t *TypeDecl) Normalize(ctx Ctx) {
	ctx.applyToken(&t.Name)
	for _, param := range t.TypeParams {
		param.Normalize(ctx)
	}
}

// IsPtr checks for * and expects exactly 1 TypeParam.
func (t *TypeDecl) IsPtr() bool {
	return t.Name.String() == "*" && len(t.TypeParams) == 1
}

// IsSlice checks for [] and expects exactly 1 TypeParam.
func (t *TypeDecl) IsSlice() bool {
	return t.Name.String() == "[]" && len(t.TypeParams) == 1
}

// IsArray checks for [] and expects exactly 2 TypeParams (first is len, second the actual type).
func (t *TypeDecl) IsArray() bool {
	return t.Name.String() == "[]" && len(t.TypeParams) == 2
}

// IsMap checks for map! and expects exactly 2 TypeParams.
func (t *TypeDecl) IsMap() bool {
	return t.Name.String() == "map!" && len(t.TypeParams) == 2
}
